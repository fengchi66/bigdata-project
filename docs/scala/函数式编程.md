# 函数式编程简介

## 面向对象编程

**解决问题，分解对象，行为，属性，然后通过对象的关系以及行为的调用来解决问题。**

- 对象：用户

- 行为：登录、连接JDBC、读取数据库

- 属性：用户名、密码

> Scala语言是一个完全面向对象编程语言。万物皆对象
>
> 对象的本质：对数据和行为的一个封装



## 函数式编程

**解决问题时，将问题分解成一个一个的步骤，将每个步骤进行封装（函数），通过调用这些封装好的步骤，解决问题。**

- 例如：请求->用户名、密码->连接JDBC->读取数据库

> Scala语言是一个完全函数式编程语言。万物皆函数。
>
> 函数的本质：函数可以当做一个值进行传递



# 函数类型

- 在`Scala`中，函数可以使用`函数字面值(Function Literal)`直接定义。有时候，函数字面值也常常称为`函数`或`函数值`。

- `在Scala中函数是一等公民`，当我们定义一个函数字面量时，实际上定义了一个包含apply方法的Scala对象。Scala对这个方法名有特别的规则，一个有apply方法的对象可以把它当成方法一样调用

```scala
val f1 = (a: String) => a.toLowerCase
```



## 匿名函数

事实上，「函数字面值」本质上是一个「匿名函数(Anonymous Function)」。在`Scala`里，函数被转换为`FunctionN`的实例。上例等价于：

```scala
val f2 = new Function[String, String] {
    override def apply(v1: String): String = v1.toLowerCase
  }
```

其中，`Function1[String, String]`可以简写为`String => String`，因此它又等价于：

```scala
  val f3 = new (String => String) {
    def apply(s: String): String = s.toLowerCase
  }
```

也就是说，「函数字面值」可以看做「匿名函数对象」的一个「语法糖」。



## 函数值

综上述，函数实际上是`FunctionN[A1, A2, ..., An, R]`类型的一个实例而已。例如`(s: String) => s.toLowerCase`是`Function1[String, String]`类型的一个实例。

在函数式编程中，`函数做为一等公民，函数值可以被自由地传递和存储。`例如，它可以赋予一个变量`lower`。

```scala
val lower: String => String = _.toLowerCase
```

假如存在一个`map`的柯里化的函数。

```scala
def map[A, B](a: A)(f: A => B): B = f(a)
```

函数值可以作为参数传递给`map`函数。

```scala
map("HORANCE") { _.toLowerCase }
```

## 有名函数

相对于「匿名函数」，如果将「函数值」赋予`def`，或者`val`，此时函数常称为「有名函数」(Named Function)。



```scala
val lower: String => String = _.toLowerCase
def lower: String => String = _.toLowerCase
```

两者之间存在微妙的差异。前者使用`val`定义的变量直接持有函数值，多次使用`lower`将返回同一个函数值；后者使用`def`定义函数，每次调用`lower`将得到不同的函数值。

## 函数调用

在`Scala`里，「函数调用」实际上等价于在`FunctionN`实例上调用`apply`方法。例如，存在一个有名函数`lower`。

```scala
val lower: String => String = _.toLowerCase
```

当发生如下函数调用时：

```scala
lower("HORANCE")
```

它等价于在`Function1[String, String]`类型的实例上调用`apply`方法。

```scala
lower.apply("HORANCE")
```



# 柯里化和闭包

## 函数柯里化(多参数列表)

柯里化(Currying)指的是将原来接受两个参数的函数变成新的接受一个参数的函数的过程。新的函数返回一个以原有第二个参数为参数的函数。

首先我们定义一个函数:

```scala
def add(x:Int,y:Int)=x+y
```

那么我们应用的时候，应该是这样用：add(1,2)

现在我们把这个函数变一下形：

```scala
def add(x:Int)(y:Int) = x + y
```

那么我们应用的时候，应该是这样用：add(1)(2),最后结果都一样是3，这种方式（过程）就叫柯里化。

#### 隐式（IMPLICIT）参数

如果要指定参数列表中的某些参数为隐式（implicit），应该使用多参数列表。例如：

```scala
def execute(arg: Int)(implicit ec: ExecutionContext) = ???
```

## 闭包

**「函数」和「函数内部能访问到的变量」（也叫环境）的总和，就是一个闭包**

```scala
var factor = 3
val adder = (i:Int) => i * factor
```

可能会有同学有疑问：浪尖，这不对啊？我看网上说的闭包构造是：
闭包首先有函数嵌套，内部函数引用外部函数的变量，然后返回的是一个函数。
应该是这个样子的：

```text
object closure {
 def main(args: Array[String]): Unit = {
   println(makeAdd()(1))
 }
 def makeAdd() = {
   val more = 10
   (x: Int) => x + more
 }
}
```

**为啥要用函数嵌套？**
需要外部函数的作用主要是隐藏变量，限制变量作用的范围。
有些人看到「闭包」这个名字，就一定觉得要用什么包起来才行。其实这是翻译问题，闭包的原文是 Closure，跟「包」没有任何关系。
所以函数套函数只是为了造出一个局部变量，跟闭包无关。

**为啥要return函数呢？**
很明显，不return函数无法使用闭包～～
那么现在换个脑子吧，我们将more 变成makeAdd的参数，那么就是下面的形式：
def makeAdd(more : Int) = (x: Int) => x + more

# 高阶函数

高阶函数通常来讲就是`函数的函数`，也就是说函数的`输出参数是函数`或者`函数的返回结果是函数`。在Scala中函数是一等公民。

我们看一下Scala集合类（collections）的高阶函数map：

```scala
val salaries = Seq(20000, 70000, 40000)
val doubleSalary = (x: Int) => x * 2
val newSalaries = salaries.map(doubleSalary) // List(40000, 140000, 80000)
```

map接收一个函数为参数。所以map是一个高阶函数，map也可直接接收一个匿名函数，如下所示：

```scala
val salaries = Seq(20000, 70000, 40000)
val newSalaries = salaries.map(x => x * 2) // List(40000, 140000, 80000)
```

在上面的例子中，我们并没有显示使用x:Int的形式，这是因为编译器可以通过类型推断推断出x的类型，对其更简化的形式是：

```scala
val salaries = Seq(20000, 70000, 40000)
val newSalaries = salaries.map(_ * 2)
```

既然Scala编译器已经知道了参数的类型（一个单独的Int），你可以只给出函数的右半部分，不过需要使用_代替参数名（在上一个例子中是x）



## 函数可以作为值进行传递

```scala
def main(args: Array[String]): Unit = {

    //（1）调用foo函数，把返回值给变量f
    //val f = foo()
    val f = foo
    println(f) // foo... 1

    //（2）在被调用函数foo后面加上 _，相当于把函数foo当成一个整体，传递给变量f1
    val f1 = foo _

    foo() // foo...
    f1() // foo...
    //（3）如果明确变量类型，那么不使用下划线也可以将函数作为整体传递给变量
    var f2: () => Int = foo
  }

  def foo(): Int = {
    println("foo...")
    1
  }
```

## 函数可以作为参数进行传递

```scala
def main(args: Array[String]): Unit = {

    // （1）定义一个函数，函数参数还是一个函数签名；f表示函数名称;(Int,Int)表示输入两个Int参数；Int表示函数返回值
    def f1(f: (Int, Int) => Int): Int = {
      f(2, 4)
    }

    // （2）定义一个函数，参数和返回值类型和f1的输入参数一致
    def add(a: Int, b: Int): Int = a + b

    // （3）将add函数作为参数传递给f1函数，如果能够推断出来不是调用，_可以省略
    println(f1(add))
    println(f1(add _))
    //可以传递匿名函数
    println(f1((a: Int, b: Int) => a + b))
  }
```

## 函数可以作为函数返回值返回

```scala
def f1() = {
    def f2() = {}
    f2 _
  }

  val f = f1()
  // 因为f1函数的返回值依然为函数，所以可以变量f可以作为函数继续调用
  f()
  // 上面的代码可以简化为
  f1()()
```

有一些情况你希望生成一个函数， 比如：

```scala
def urlBuilder(ssl: Boolean, domainName: String): (String, String) => String = {
  val schema = if (ssl) "https://" else "http://"
  (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
}

val domainName = "www.example.com"
def getURL = urlBuilder(ssl=true, domainName)
val endpoint = "users"
val query = "id=1"
val url = getURL(endpoint, query) // "https://www.example.com/users?id=1": String
```

注意urlBuilder的返回类型是`(String, String) => String`，这意味着返回的匿名函数有两个String参数，返回一个String。在这个例子中，返回的匿名函数是`(endpoint: String, query: String) => s"https://www.example.com/$endpoint?$query"`。



# 偏函数

