# 函数式编程简介

## 面向对象编程

**解决问题，分解对象，行为，属性，然后通过对象的关系以及行为的调用来解决问题。**

- 对象：用户

- 行为：登录、连接JDBC、读取数据库

- 属性：用户名、密码

> Scala语言是一个完全面向对象编程语言。万物皆对象
>
> 对象的本质：对数据和行为的一个封装



## 函数式编程

**解决问题时，将问题分解成一个一个的步骤，将每个步骤进行封装（函数），通过调用这些封装好的步骤，解决问题。**

- 例如：请求->用户名、密码->连接JDBC->读取数据库

> Scala语言是一个完全函数式编程语言。万物皆函数。
>
> 函数的本质：函数可以当做一个值进行传递



# 函数类型

- 在`Scala`中，函数可以使用`函数字面值(Function Literal)`直接定义。有时候，函数字面值也常常称为`函数`或`函数值`。

- `在Scala中函数是一等公民`，当我们定义一个函数字面量时，实际上定义了一个包含apply方法的Scala对象。Scala对这个方法名有特别的规则，一个有apply方法的对象可以把它当成方法一样调用

```scala
val f1 = (a: String) => a.toLowerCase
```



## 匿名函数

事实上，「函数字面值」本质上是一个「匿名函数(Anonymous Function)」。在`Scala`里，函数被转换为`FunctionN`的实例。上例等价于：

```scala
val f2 = new Function[String, String] {
    override def apply(v1: String): String = v1.toLowerCase
  }
```

其中，`Function1[String, String]`可以简写为`String => String`，因此它又等价于：

```scala
  val f3 = new (String => String) {
    def apply(s: String): String = s.toLowerCase
  }
```

也就是说，「函数字面值」可以看做「匿名函数对象」的一个「语法糖」。



## 函数值

综上述，函数实际上是`FunctionN[A1, A2, ..., An, R]`类型的一个实例而已。例如`(s: String) => s.toLowerCase`是`Function1[String, String]`类型的一个实例。

在函数式编程中，`函数做为一等公民，函数值可以被自由地传递和存储。`例如，它可以赋予一个变量`lower`。

```scala
val lower: String => String = _.toLowerCase
```

假如存在一个`map`的柯里化的函数。

```scala
def map[A, B](a: A)(f: A => B): B = f(a)
```

函数值可以作为参数传递给`map`函数。

```scala
map("HORANCE") { _.toLowerCase }
```

## 有名函数

相对于「匿名函数」，如果将「函数值」赋予`def`，或者`val`，此时函数常称为「有名函数」(Named Function)。



```scala
val lower: String => String = _.toLowerCase
def lower: String => String = _.toLowerCase
```

两者之间存在微妙的差异。前者使用`val`定义的变量直接持有函数值，多次使用`lower`将返回同一个函数值；后者使用`def`定义函数，每次调用`lower`将得到不同的函数值。

## 函数调用

在`Scala`里，「函数调用」实际上等价于在`FunctionN`实例上调用`apply`方法。例如，存在一个有名函数`lower`。

```scala
val lower: String => String = _.toLowerCase
```

当发生如下函数调用时：

```scala
lower("HORANCE")
```

它等价于在`Function1[String, String]`类型的实例上调用`apply`方法。

```scala
lower.apply("HORANCE")
```



# 柯里化和闭包

## 函数柯里化

柯里化(Currying)指的是将原来接受两个参数的函数变成新的接受一个参数的函数的过程。新的函数返回一个以原有第二个参数为参数的函数。

首先我们定义一个函数:

```scala
def add(x:Int,y:Int)=x+y
```

那么我们应用的时候，应该是这样用：add(1,2)

现在我们把这个函数变一下形：

```scala
def add(x:Int)(y:Int) = x + y
```

那么我们应用的时候，应该是这样用：add(1)(2),最后结果都一样是3，这种方式（过程）就叫柯里化。









## 闭包

